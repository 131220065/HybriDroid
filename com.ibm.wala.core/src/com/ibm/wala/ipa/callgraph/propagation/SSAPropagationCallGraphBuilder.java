/*******************************************************************************
 * Copyright (c) 2002 - 2006 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package com.ibm.wala.ipa.callgraph.propagation;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import com.ibm.wala.analysis.reflection.CloneInterpreter;
import com.ibm.wala.analysis.reflection.Malleable;
import com.ibm.wala.cfg.ControlFlowGraph;
import com.ibm.wala.cfg.IBasicBlock;
import com.ibm.wala.classLoader.ArrayClass;
import com.ibm.wala.classLoader.CallSiteReference;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IField;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.classLoader.ProgramCounter;
import com.ibm.wala.fixedpoint.impl.UnaryOperator;
import com.ibm.wala.fixpoint.IVariable;
import com.ibm.wala.fixpoint.IntSetVariable;
import com.ibm.wala.ipa.callgraph.AnalysisOptions;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.CallGraph;
import com.ibm.wala.ipa.callgraph.ContextKey;
import com.ibm.wala.ipa.callgraph.impl.ExplicitCallGraph;
import com.ibm.wala.ipa.callgraph.impl.FakeRootMethod;
import com.ibm.wala.ipa.callgraph.impl.FakeWorldClinitMethod;
import com.ibm.wala.ipa.cha.ClassHierarchy;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.shrikeBT.ConditionalBranchInstruction;
import com.ibm.wala.shrikeBT.IInvokeInstruction;
import com.ibm.wala.ssa.DefUse;
import com.ibm.wala.ssa.IR;
import com.ibm.wala.ssa.SSAAbstractInvokeInstruction;
import com.ibm.wala.ssa.SSAAbstractThrowInstruction;
import com.ibm.wala.ssa.SSAArrayLoadInstruction;
import com.ibm.wala.ssa.SSAArrayStoreInstruction;
import com.ibm.wala.ssa.SSACFG;
import com.ibm.wala.ssa.SSACheckCastInstruction;
import com.ibm.wala.ssa.SSAConditionalBranchInstruction;
import com.ibm.wala.ssa.SSAGetCaughtExceptionInstruction;
import com.ibm.wala.ssa.SSAGetInstruction;
import com.ibm.wala.ssa.SSAInstanceofInstruction;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.ssa.SSAInvokeInstruction;
import com.ibm.wala.ssa.SSALoadClassInstruction;
import com.ibm.wala.ssa.SSANewInstruction;
import com.ibm.wala.ssa.SSAPhiInstruction;
import com.ibm.wala.ssa.SSAPiInstruction;
import com.ibm.wala.ssa.SSAPutInstruction;
import com.ibm.wala.ssa.SSAReturnInstruction;
import com.ibm.wala.ssa.SSAThrowInstruction;
import com.ibm.wala.ssa.SymbolTable;
import com.ibm.wala.ssa.SSACFG.BasicBlock;
import com.ibm.wala.ssa.SSACFG.ExceptionHandlerBasicBlock;
import com.ibm.wala.types.FieldReference;
import com.ibm.wala.types.MethodReference;
import com.ibm.wala.types.Selector;
import com.ibm.wala.types.TypeReference;
import com.ibm.wala.util.ReferenceCleanser;
import com.ibm.wala.util.collections.HashSetFactory;
import com.ibm.wala.util.debug.Assertions;
import com.ibm.wala.util.debug.Trace;
import com.ibm.wala.util.intset.IntIterator;
import com.ibm.wala.util.intset.IntSet;
import com.ibm.wala.util.intset.IntSetAction;
import com.ibm.wala.util.intset.IntSetUtil;
import com.ibm.wala.util.intset.MutableIntSet;
import com.ibm.wala.util.warnings.ResolutionFailure;
import com.ibm.wala.util.warnings.Warning;
import com.ibm.wala.util.warnings.WarningSet;

/**
 * 
 * This abstract base class provides the general algorithm for a call graph
 * builder that relies on propagation through an iterative dataflow solver, and
 * constraints generated by statements in SSA form.
 * 
 * TODO: This implementation currently keeps all points to sets live ... even
 * those for local variables that do not span interprocedural boundaries. This
 * may be too space-inefficient .. we can consider recomputing local sets on
 * demand.
 * 
 * @author sfink
 * @author adonovan
 */
public abstract class SSAPropagationCallGraphBuilder extends PropagationCallGraphBuilder implements HeapModel {
  private final static boolean DEBUG = false;

  private final static boolean DEBUG_MULTINEWARRAY = DEBUG | false;

  private final static String DEBUG_METHOD_SUBSTRING = null;

  /**
   * Should we periodically clear out soft reference caches in an attempt to
   * help the GC?
   */
  public final static boolean PERIODIC_WIPE_SOFT_CACHES = true;

  /**
   * Interval which defines the period to clear soft reference caches
   */
  public final static int WIPE_SOFT_CACHE_INTERVAL = 2500;

  /**
   * Counter for wiping soft caches
   */
  private static int wipeCount = 0;

  /**
   * use type inference to avoid unnecessary filter constraints?
   */
  // private final static boolean OPTIMIZE_WITH_TYPE_INFERENCE = true;
  /**
   * An optimization: if we can locally determine the final solution for a
   * points-to set, then don't actually create the points-to set, but instead
   * short circuit by propagating the final solution to all such uses.
   * 
   * String constants are ALWAYS considered invariant, regardless of the value
   * of this flag.
   * 
   * However, if this flag is set, then the solver is more aggressive
   * identifying invariants.
   * 
   * Doesn't play well with pre-transitive solver; turning off for now.
   */
  private final static boolean SHORT_CIRCUIT_INVARIANT_SETS = true;

  /**
   * An optimization: if we can locally determine that a particular pointer p
   * has exactly one use, then we don't actually create the points-to-set for p,
   * but instead short-circuit by propagating the final solution to the unique
   * use.
   * 
   * Doesn't play well with pre-transitive solver; turning off for now.
   */
  protected final static boolean SHORT_CIRCUIT_SINGLE_USES = true;

  /**
   * Should we change calls to clone() to assignments?
   */
  private final boolean clone2Assign = false;

  /**
   * Cache for efficiency
   */
  private final static Selector cloneSelector = CloneInterpreter.CLONE.getSelector();

  /**
   * set of class whose clinits have already been processed
   */
  private final Set<IClass> clinitVisited = HashSetFactory.make();

  /**
   * Set of CGNode numbers that have no instructions for Node number n:
   * emptyNodeNumber[2n] marks whether we have counted the instructions
   * emptyNodeNumber[2n+1] marks whether the number of instructions == 0
   */
  // private final BitVector emptyNodeNumbers = new BitVector();
  /**
   * Should we use the pre-transitive solver?
   */
  private final boolean usePreTransitiveSolver;

  protected SSAPropagationCallGraphBuilder(ClassHierarchy cha, WarningSet warnings, AnalysisOptions options,
      PointerKeyFactory pointerKeyFactory) {
    super(cha, warnings, options, pointerKeyFactory);
    this.usePreTransitiveSolver = options.usePreTransitiveSolver();
  }

  public SSAContextInterpreter getCFAContextInterpreter() {
    return (SSAContextInterpreter) getContextInterpreter();
  }

  /**
   * @param node
   * @param x
   * @param type
   * @return the instance key that represents the exception of type _type_
   *         thrown by a particular PEI.
   * @throws IllegalArgumentException  if ikFactory is null
   */
  public static InstanceKey getInstanceKeyForPEI(CGNode node, ProgramCounter x, TypeReference type, InstanceKeyFactory ikFactory) {
    if (ikFactory == null) {
      throw new IllegalArgumentException("ikFactory is null");
    }
    return ikFactory.getInstanceKeyForPEI(node, x, type);
  }

  /**
   * Visit all instructions in a node, and add dataflow constraints induced by
   * each statement in the SSA form.
   * 
   * @see com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder#addConstraintsFromNode(com.ibm.wala.ipa.callgraph.CGNode)
   */
  protected boolean addConstraintsFromNode(CGNode node) {
    if (haveAlreadyVisited(node)) {
      return false;
    } else {
      markAlreadyVisited(node);
    }
    return unconditionallyAddConstraintsFromNode(node);
  }

  /**
   * @param node
   */
  protected boolean unconditionallyAddConstraintsFromNode(CGNode node) {

    boolean debug;
    if (PERIODIC_WIPE_SOFT_CACHES) {
      wipeCount++;
      if (wipeCount >= WIPE_SOFT_CACHE_INTERVAL) {
        wipeCount = 0;
        ReferenceCleanser.clearSoftCaches();
      }
    }

    debug = false;
    if (DEBUG) {
      debug = Trace.guardedPrintln("\n\nAdd constraints from node " + node, DEBUG_METHOD_SUBSTRING);
    }
    IR ir = getCFAContextInterpreter().getIR(node, getWarnings());
    if (DEBUG && debug) {
      if (ir == null) {
        Trace.println("\n   No statements\n");
      } else {
        try {
          Trace.println(ir.toString());
        } catch (Error e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      }
    }

    if (ir == null) {
      return false;
    }

    DefUse du = getCFAContextInterpreter().getDU(node, getWarnings());
    addNodeInstructionConstraints(node, ir, du);
    addNodePassthruExceptionConstraints(node, ir, du);
    // conservatively assume something changed
    return true;
  }

  /**
   * @param node
   * @param ir
   * @param callGraph
   * @return a visitor to examine instructions in the ir
   */
  protected ConstraintVisitor makeVisitor(ExplicitCallGraph.ExplicitNode node, IR ir, DefUse du, ExplicitCallGraph callGraph) {
    return new ConstraintVisitor(node, ir, callGraph, du);
  }

  /**
   * Add pointer flow constraints based on instructions in a given node
   * 
   * @param node
   * @param ir
   */
  protected void addNodeInstructionConstraints(CGNode node, IR ir, DefUse du) {
    ConstraintVisitor v = makeVisitor((ExplicitCallGraph.ExplicitNode) node, ir, du, callGraph);
    ControlFlowGraph cfg = ir.getControlFlowGraph();
    for (Iterator x = cfg.iterator(); x.hasNext();) {
      BasicBlock b = (BasicBlock) x.next();
      addBlockInstructionConstraints(node, cfg, b, v);
      if (wasChanged(node)) {
        return;
      }
    }
  }

  /**
   * Add constraints for a particular basic block.
   * 
   * @param node
   * @param cfg
   * @param b
   * @param v
   */
  protected void addBlockInstructionConstraints(CGNode node, ControlFlowGraph cfg, BasicBlock b, ConstraintVisitor v) {
    v.setBasicBlock(b);

    // visit each instruction in the basic block.
    for (Iterator it = b.iterator(); it.hasNext();) {
      SSAInstruction s = (SSAInstruction) it.next();
      if (s != null) {
        s.visit(v);
        if (wasChanged(node)) {
          return;
        }
      }
    }

    addPhiConstraints(node, cfg, b, v);
  }

  /**
   * @param node
   * @param cfg
   * @param b
   * @param v
   */
  private void addPhiConstraints(CGNode node, ControlFlowGraph cfg, BasicBlock b, ConstraintVisitor v) {
    // visit each phi instruction in each successor block
    for (Iterator sbs = cfg.getSuccNodes(b); sbs.hasNext();) {
      BasicBlock sb = (BasicBlock) sbs.next();
      if (sb.isExitBlock()) {
        // an optimization based on invariant that exit blocks should have no
        // phis.
        continue;
      }
      int n = 0;
      for (Iterator back = cfg.getPredNodes(sb); back.hasNext(); n++) {
        if (back.next() == b) {
          break;
        }
      }
      if (DEBUG && Assertions.verifyAssertions) {
        Assertions._assert(n < cfg.getPredNodeCount(sb));
      }
      for (Iterator phis = sb.iteratePhis(); phis.hasNext();) {
        SSAPhiInstruction phi = (SSAPhiInstruction) phis.next();
        if (phi == null) {
          continue;
        }
        PointerKey def = getPointerKeyForLocal(node, phi.getDef());
        if (hasNoInterestingUses(phi.getDef(), v.du)) {
          system.recordImplicitPointsToSet(def);
        } else {
          // the following test restricts the constraints to reachable
          // paths, according to verification constraints
          if (phi.getUse(n) > 0) {
            PointerKey use = getPointerKeyForLocal(node, phi.getUse(n));
            if (contentsAreInvariant(v.symbolTable, v.du, phi.getUse(n))) {
              system.recordImplicitPointsToSet(use);
              InstanceKey[] ik = getInvariantContents(v.symbolTable, v.du, node, phi.getUse(n), SSAPropagationCallGraphBuilder.this);
              for (int i = 0; i < ik.length; i++) {
                system.newConstraint(def, ik[i]);
              }
            } else {
              system.newConstraint(def, assignOperator, use);
            }
          }
        }
      }
    }
  }

  /**
   * Add constraints to represent the flow of exceptions to the exceptional
   * return value for this node
   * 
   * @param node
   * @param ir
   */
  protected void addNodePassthruExceptionConstraints(CGNode node, IR ir, DefUse du) {
    // add constraints relating to thrown exceptions that reach the exit block.
    List<ProgramCounter> peis = getIncomingPEIs(ir, ir.getExitBlock());
    PointerKey exception = getPointerKeyForExceptionalReturnValue(node);

    addExceptionDefConstraints(ir, du, node, peis, exception, THROWABLE_SET);
  }

  /**
   * Generate constraints which assign exception values into an exception
   * pointer
   * 
   * @param node
   *          governing node
   * @param peis
   *          list of PEI instructions
   * @param exceptionVar
   *          PointerKey representing a pointer to an exception value
   * @param catchClasses
   *          the types "caught" by the exceptionVar
   */
  private void addExceptionDefConstraints(IR ir, DefUse du, CGNode node, List<ProgramCounter> peis, PointerKey exceptionVar,
      Set catchClasses) {
    boolean debug = false;
    if (DEBUG) {
      debug = Trace.guardedPrintln("Add exception def constraints for node " + node, DEBUG_METHOD_SUBSTRING);
    }
    for (Iterator<ProgramCounter> it = peis.iterator(); it.hasNext();) {
      ProgramCounter peiLoc = it.next();
      if (DEBUG) {
        Trace.println("peiLoc: " + peiLoc);
      }
      SSAInstruction pei = ir.getPEI(peiLoc);

      if (DEBUG && debug) {
        Trace.println("Add exceptions from pei " + pei);
      }

      if (pei instanceof SSAAbstractInvokeInstruction) {
        SSAAbstractInvokeInstruction s = (SSAAbstractInvokeInstruction) pei;
        PointerKey e = getPointerKeyForLocal(node, s.getException());

        if (!SHORT_CIRCUIT_SINGLE_USES || !hasUniqueCatchBlock(s, ir)) {
          addAssignmentsForCatchPointerKey(exceptionVar, catchClasses, e);
        }// else {
        // Trace.println("SKIPPING ASSIGNMENTS TO " + exceptionVar + " FROM " +
        // e);
        // }
      } else if (pei instanceof SSAAbstractThrowInstruction) {
        SSAAbstractThrowInstruction s = (SSAAbstractThrowInstruction) pei;
        PointerKey e = getPointerKeyForLocal(node, s.getException());

        if (contentsAreInvariant(ir.getSymbolTable(), du, s.getException())) {
          InstanceKey[] ik = getInvariantContents(ir.getSymbolTable(), du, node, s.getException(),
              SSAPropagationCallGraphBuilder.this);
          for (int i = 0; i < ik.length; i++) {
            system.findOrCreateIndexForInstanceKey(ik[i]);
            assignInstanceToCatch(exceptionVar, catchClasses, ik[i]);
          }
        } else {
          addAssignmentsForCatchPointerKey(exceptionVar, catchClasses, e);
        }
      }

      // Account for those exceptions for which we do not actually have a
      // points-to set for
      // the pei, but just instance keys
      Collection types = pei.getExceptionTypes();
      if (types != null) {
        for (Iterator it2 = types.iterator(); it2.hasNext();) {
          TypeReference type = (TypeReference) it2.next();
          if (type != null) {
            InstanceKey ik = getInstanceKeyForPEI(node, peiLoc, type, instanceKeyFactory);
            if (Assertions.verifyAssertions) {
              if (!(ik instanceof ConcreteTypeKey)) {
                Assertions._assert(ik instanceof ConcreteTypeKey,
                    "uh oh: need to implement getCaughtException constraints for instance " + ik);
              }
            }
            ConcreteTypeKey ck = (ConcreteTypeKey) ik;
            IClass klass = ck.getType();
            if (SSAPropagationCallGraphBuilder.catches(catchClasses, klass, cha)) {
              system.newConstraint(exceptionVar, getInstanceKeyForPEI(node, peiLoc, type, instanceKeyFactory));
            }
          }
        }
      }
    }
  }

  /**
   * @param call
   * @param ir
   * @return true iff there's a unique catch block which catches all exceptions
   *         thrown by a certain call site.
   */
  protected static boolean hasUniqueCatchBlock(SSAAbstractInvokeInstruction call, IR ir) {
    IBasicBlock[] bb = ir.getBasicBlocksForCall(call.getCallSite());
    if (bb.length == 1) {
      Iterator it = ir.getControlFlowGraph().getExceptionalSuccessors(bb[0]).iterator();
      // check that there's exactly one element in the iterator
      if (it.hasNext()) {
        it.next();
        return (!it.hasNext());
      }
    }
    return false;
  }

  /**
   * @return true iff there's a unique catch block which catches all exceptions
   *         thrown by a certain call site.
   */
  static boolean hasUniqueCatchBlock(SSAAbstractInvokeInstruction call, CGNode node, CallGraph cg) {
    SSAContextInterpreter interp = cg.getInterpreter(node);
    return hasUniqueCatchBlock(call, interp.getIR(node, new WarningSet()));
  }

  /**
   * precondition: hasUniqueCatchBlock(call,node,cg)
   * 
   * @return the unique pointer key which catches the exceptions thrown by a
   *         call
   */
  protected PointerKey getUniqueCatchKey(SSAAbstractInvokeInstruction call, IR ir, CGNode node) {
    IBasicBlock[] bb = ir.getBasicBlocksForCall(call.getCallSite());
    if (Assertions.verifyAssertions) {
      Assertions._assert(bb.length == 1);
    }
    SSACFG.BasicBlock cb = (BasicBlock) ir.getControlFlowGraph().getExceptionalSuccessors(bb[0]).iterator().next();
    if (cb.isExitBlock()) {
      return getPointerKeyForExceptionalReturnValue(node);
    } else {
      SSACFG.ExceptionHandlerBasicBlock ehbb = (ExceptionHandlerBasicBlock) cb;
      SSAGetCaughtExceptionInstruction ci = ehbb.getCatchInstruction();
      return getPointerKeyForLocal(node, ci.getDef());
    }
  }

  /**
   * @return a List of Instructions that may transfer control to bb via an
   *         exceptional edge
   * @throws IllegalArgumentException  if ir is null
   */
  public static List<ProgramCounter> getIncomingPEIs(IR ir, IBasicBlock bb) {
    if (ir == null) {
      throw new IllegalArgumentException("ir is null");
    }
    if (DEBUG) {
      Trace.println("getIncomingPEIs " + bb);
    }
    ControlFlowGraph G = ir.getControlFlowGraph();
    List<ProgramCounter> result = new ArrayList<ProgramCounter>(G.getPredNodeCount(bb));
    for (Iterator it = G.getPredNodes(bb); it.hasNext();) {
      BasicBlock pred = (BasicBlock) it.next();
      if (DEBUG) {
        Trace.println("pred: " + pred);
      }
      if (pred.isEntryBlock())
        continue;
      int index = pred.getLastInstructionIndex();
      SSAInstruction pei = ir.getInstructions()[index];
      // Note: pei might be null if pred is unreachable.
      // TODO: consider pruning CFG for unreachable blocks.
      if (pei != null && pei.isPEI()) {
        if (DEBUG) {
          Trace.println("PEI: " + pei + " index " + index + " PC " + G.getProgramCounter(index));
        }
        result.add(new ProgramCounter(G.getProgramCounter(index)));
      }
    }
    return result;
  }

  /**
   * A visitor that generates constraints based on statements in SSA form.
   */
  protected class ConstraintVisitor extends SSAInstruction.Visitor {

    /**
     * The node whose statements we are currently traversing
     */
    protected final ExplicitCallGraph.ExplicitNode node;

    /**
     * The governing call graph.
     */
    private final ExplicitCallGraph callGraph;

    /**
     * The governing IR
     */
    protected final IR ir;

    /**
     * The basic block currently being processed
     */
    private IBasicBlock basicBlock;

    /**
     * Governing symbol table
     */
    protected final SymbolTable symbolTable;

    /**
     * Def-use information
     */
    protected final DefUse du;

    private final boolean debug;

    public ConstraintVisitor(ExplicitCallGraph.ExplicitNode node, IR ir, ExplicitCallGraph callGraph, DefUse du) {
      this.node = node;
      this.ir = ir;
      this.symbolTable = ir.getSymbolTable();
      this.callGraph = callGraph;
      this.debug = DEBUG_METHOD_SUBSTRING == null || node.toString().indexOf(DEBUG_METHOD_SUBSTRING) > -1;
      if (Assertions.verifyAssertions) {
        Assertions._assert(symbolTable != null);
      }
      // this.ti = OPTIMIZE_WITH_TYPE_INFERENCE ? makeTypeInference(ir,
      // callGraph.getClassHierarchy()) : null;
      this.du = du;

    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.SSAInstruction.Visitor#visitArrayLoad(com.ibm.wala.ssa.SSAArrayLoadInstruction)
     */
    public void visitArrayLoad(SSAArrayLoadInstruction instruction) {
      // skip arrays of primitive type
      if (instruction.typeIsPrimitive()) {
        return;
      }
      PointerKey result = getPointerKeyForLocal(node, instruction.getDef());
      PointerKey arrayRef = getPointerKeyForLocal(node, instruction.getArrayRef());
      if (hasNoInterestingUses(instruction.getDef(), du)) {
        system.recordImplicitPointsToSet(result);
      } else {
        if (contentsAreInvariant(symbolTable, du, instruction.getArrayRef())) {
          system.recordImplicitPointsToSet(arrayRef);
          InstanceKey[] ik = getInvariantContents(symbolTable, du, node, instruction.getArrayRef(),
              SSAPropagationCallGraphBuilder.this);
          for (int i = 0; i < ik.length; i++) {
            system.findOrCreateIndexForInstanceKey(ik[i]);
            PointerKey p = getPointerKeyForArrayContents(ik[i]);
            if (p == null) {
              getWarnings().add(ResolutionFailure.create(node, ik[i].getConcreteType()));
            } else {
              system.newConstraint(result, assignOperator, p);
            }
          }
        } else {
          if (Assertions.verifyAssertions) {
            Assertions._assert(!system.isUnified(result));
            Assertions._assert(!system.isUnified(arrayRef));
          }
          system.newSideEffect(new ArrayLoadOperator(system.findOrCreatePointsToSet(result)), arrayRef);
        }
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.SSAInstruction.Visitor#visitArrayStore(com.ibm.wala.ssa.SSAArrayStoreInstruction)
     */
    public void visitArrayStore(SSAArrayStoreInstruction instruction) {
      // skip arrays of primitive type
      if (instruction.typeIsPrimitive()) {
        return;
      }

      // (requires the creation of assign constraints as
      // the set points-to(a[]) grows.)
      PointerKey value = getPointerKeyForLocal(node, instruction.getValue());
      PointerKey arrayRef = getPointerKeyForLocal(node, instruction.getArrayRef());
      // if (!supportFullPointerFlowGraph &&
      // contentsAreInvariant(instruction.getArrayRef())) {
      if (contentsAreInvariant(symbolTable, du, instruction.getArrayRef())) {
        system.recordImplicitPointsToSet(arrayRef);
        InstanceKey[] ik = getInvariantContents(symbolTable, du, node, instruction.getArrayRef(),
            SSAPropagationCallGraphBuilder.this);

        for (int i = 0; i < ik.length; i++) {
          system.findOrCreateIndexForInstanceKey(ik[i]);
          PointerKey p = getPointerKeyForArrayContents(ik[i]);
          IClass contents = ((ArrayClass) ik[i].getConcreteType()).getElementClass();
          if (p == null) {
            getWarnings().add(ResolutionFailure.create(node, ik[i].getConcreteType()));
          } else {
            if (DEBUG_TRACK_INSTANCE) {
              if (system.findOrCreateIndexForInstanceKey(ik[i]) == DEBUG_INSTANCE_KEY) {
                Assertions.UNREACHABLE();
              }
            }
            if (contentsAreInvariant(symbolTable, du, instruction.getValue())) {
              system.recordImplicitPointsToSet(value);
              InstanceKey[] vk = getInvariantContents(symbolTable, du, node, instruction.getValue(),
                  SSAPropagationCallGraphBuilder.this);
              for (int j = 0; j < vk.length; j++) {
                system.findOrCreateIndexForInstanceKey(vk[j]);
                if (vk[j].getConcreteType() != null) {
                  if (getClassHierarchy().isAssignableFrom(contents, vk[j].getConcreteType())) {
                    system.newConstraint(p, vk[j]);
                  }
                }
              }
            } else {
              if (isRootType(contents)) {
                system.newConstraint(p, assignOperator, value);
              } else {
                system.newConstraint(p, filterOperator, value);
              }
            }
          }
        }
      } else {
        if (contentsAreInvariant(symbolTable, du, instruction.getValue())) {
          system.recordImplicitPointsToSet(value);
          InstanceKey[] ik = getInvariantContents(symbolTable, du, node, instruction.getValue(),
              SSAPropagationCallGraphBuilder.this);
          for (int i = 0; i < ik.length; i++) {
            system.findOrCreateIndexForInstanceKey(ik[i]);
            if (Assertions.verifyAssertions) {
              Assertions._assert(!system.isUnified(arrayRef));
            }
            system.newSideEffect(new InstanceArrayStoreOperator(ik[i]), arrayRef);
          }
        } else {
          system.newSideEffect(new ArrayStoreOperator(system.findOrCreatePointsToSet(value)), arrayRef);
        }
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.SSAInstruction.Visitor#visitCheckCast(com.ibm.wala.ssa.SSACheckCastInstruction)
     */
    public void visitCheckCast(SSACheckCastInstruction instruction) {

      IClass cls = getClassHierarchy().lookupClass(instruction.getDeclaredResultType());
      PointerKey result = null;
      if (cls == null) {
        getWarnings().add(CheckcastFailure.create(instruction.getDeclaredResultType()));
        // we failed to find the type.
        // conservatively it would make sense to ignore the filter and be
        // conservative, assuming
        // java.lang.Object.
        // however, this breaks the invariants downstream that assume every
        // variable is
        // strongly typed ... we can't have bad types flowing around.
        // since things are broken anyway, just give up.
        // result = getPointerKeyForLocal(node, instruction.getResult());
        return;
      } else {
        result = getFilteredPointerKeyForLocal(node, instruction.getResult(), cls);
      }
      PointerKey value = getPointerKeyForLocal(node, instruction.getVal());

      if (hasNoInterestingUses(instruction.getDef(), du)) {
        system.recordImplicitPointsToSet(result);
      } else {
        if (contentsAreInvariant(symbolTable, du, instruction.getVal())) {
          system.recordImplicitPointsToSet(value);
          InstanceKey[] ik = getInvariantContents(symbolTable, du, node, instruction.getVal(), SSAPropagationCallGraphBuilder.this);
          if (cls.isInterface()) {
            for (int i = 0; i < ik.length; i++) {
              system.findOrCreateIndexForInstanceKey(ik[i]);
              if (getClassHierarchy().implementsInterface(ik[i].getConcreteType(), cls.getReference())) {
                system.newConstraint(result, ik[i]);
              }
            }
          } else {
            for (int i = 0; i < ik.length; i++) {
              system.findOrCreateIndexForInstanceKey(ik[i]);
              if (getClassHierarchy().isSubclassOf(ik[i].getConcreteType(), cls)) {
                system.newConstraint(result, ik[i]);
              }
            }
          }
        } else {
          if (cls == null) {
            getWarnings().add(ResolutionFailure.create(node, instruction.getDeclaredResultType()));
            cls = getJavaLangObject();
          }
          if (isRootType(cls)) {
            system.newConstraint(result, assignOperator, value);
          } else {
            system.newConstraint(result, filterOperator, value);
          }
        }
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.SSAInstruction.Visitor#visitReturn(com.ibm.wala.ssa.SSAReturnInstruction)
     */
    public void visitReturn(SSAReturnInstruction instruction) {
      // skip returns of primitive type
      if (instruction.returnsPrimitiveType() || instruction.returnsVoid()) {
        return;
      }
      PointerKey returnValue = getPointerKeyForReturnValue(node);
      PointerKey result = getPointerKeyForLocal(node, instruction.getResult());
      // if (!supportFullPointerFlowGraph &&
      // contentsAreInvariant(instruction.getResult())) {
      if (contentsAreInvariant(symbolTable, du, instruction.getResult())) {
        system.recordImplicitPointsToSet(result);
        InstanceKey[] ik = getInvariantContents(symbolTable, du, node, instruction.getResult(), SSAPropagationCallGraphBuilder.this);
        for (int i = 0; i < ik.length; i++) {
          system.newConstraint(returnValue, ik[i]);
        }
      } else {
        system.newConstraint(returnValue, assignOperator, result);
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.SSAInstruction.Visitor#visitGet(com.ibm.wala.ssa.SSAGetInstruction)
     */
    public void visitGet(SSAGetInstruction instruction) {
      visitGetInternal(instruction.getDef(), instruction.getRef(), instruction.isStatic(), instruction.getDeclaredField());
    }

    protected void visitGetInternal(int lval, int ref, boolean isStatic, FieldReference field) {

      if (DEBUG) {
        Trace.guardedPrintln("visitGet " + field, DEBUG_METHOD_SUBSTRING);
      }

      // skip getfields of primitive type (optimisation)
      if (field.getFieldType().isPrimitiveType()) {
        return;
      }
      PointerKey def = getPointerKeyForLocal(node, lval);
      if (Assertions.verifyAssertions) {
        Assertions._assert(def != null);
      }

      IField f = getClassHierarchy().resolveField(field);
      if (f == null && callGraph.getFakeRootNode().getMethod().getDeclaringClass().getReference().equals(field.getDeclaringClass())) {
        f = callGraph.getFakeRootNode().getMethod().getDeclaringClass().getField(field.getName());
      }

      if (f == null) {
        getWarnings().add(ResolutionFailure.create(node, field));
        return;
      }

      if (hasNoInterestingUses(lval, du)) {
        system.recordImplicitPointsToSet(def);
      } else {
        if (isStatic) {
          PointerKey fKey = getPointerKeyForStaticField(f);
          system.newConstraint(def, assignOperator, fKey);
          IClass klass = getClassHierarchy().lookupClass(field.getDeclaringClass());
          if (klass == null) {
            getWarnings().add(ResolutionFailure.create(node, field.getDeclaringClass()));
          } else {
            // side effect of getstatic: may call class initializer
            if (DEBUG) {
              Trace.guardedPrintln("getstatic call class init " + klass, DEBUG_METHOD_SUBSTRING);
            }
            processClassInitializer(klass);
          }
        } else {
          PointerKey refKey = getPointerKeyForLocal(node, ref);
          // if (!supportFullPointerFlowGraph &&
          // contentsAreInvariant(ref)) {
          if (contentsAreInvariant(symbolTable, du, ref)) {
            system.recordImplicitPointsToSet(refKey);
            InstanceKey[] ik = getInvariantContents(symbolTable, du, node, ref, SSAPropagationCallGraphBuilder.this);
            for (int i = 0; i < ik.length; i++) {
              system.findOrCreateIndexForInstanceKey(ik[i]);
              PointerKey p = getPointerKeyForInstanceField(ik[i], f);
              system.newConstraint(def, assignOperator, p);
            }
          } else {
            system.newSideEffect(new GetFieldOperator(f, system.findOrCreatePointsToSet(def)), refKey);
          }
        }
      }
    }

    /**
     * TODO: lift most of this logic to PropagationCallGraphBuilder
     * 
     * Add a call to the class initializer from the root method.
     * 
     * @param klass
     */
    private void processClassInitializer(IClass klass) {

      if (Assertions.verifyAssertions) {
        Assertions._assert(klass != null);
      }

      if (clinitVisited.contains(klass)) {
        return;
      }
      clinitVisited.add(klass);

      if (klass.getClassInitializer() != null) {
        if (DEBUG) {
          Trace.guardedPrintln("process class initializer for " + klass, DEBUG_METHOD_SUBSTRING);
        }

        // add an invocation from the fake root method to the <clinit>
        FakeWorldClinitMethod fakeWorldClinitMethod = (FakeWorldClinitMethod) callGraph.getFakeWorldClinitNode().getMethod();
        MethodReference m = klass.getClassInitializer().getReference();
        CallSiteReference site = CallSiteReference.make(1, m, IInvokeInstruction.Dispatch.STATIC);
        IMethod targetMethod = options.getMethodTargetSelector().getCalleeTarget(callGraph.getFakeRootNode(), site, null);
        if (targetMethod != null) {
          CGNode target = getTargetForCall(callGraph.getFakeRootNode(), site, (InstanceKey) null);
          if (callGraph.getPredNodeCount(target) == 0) {
            SSAAbstractInvokeInstruction s = fakeWorldClinitMethod.addInvocation(new int[0], site);
            PointerKey uniqueCatch = getPointerKeyForExceptionalReturnValue(callGraph.getFakeRootNode());
            processResolvedCall(callGraph.getFakeWorldClinitNode(), s, target, computeInvariantParameters(s), uniqueCatch);
          }
        }
      }

      try {
        IClass sc = klass.getSuperclass();
        if (sc != null) {
          processClassInitializer(sc);
        }
      } catch (ClassHierarchyException e) {
        Assertions.UNREACHABLE();
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.Instruction.Visitor#visitPut(com.ibm.wala.ssa.PutInstruction)
     */
    public void visitPut(SSAPutInstruction instruction) {
      visitPutInternal(instruction.getVal(), instruction.getRef(), instruction.isStatic(), instruction.getDeclaredField());
    }

    public void visitPutInternal(int rval, int ref, boolean isStatic, FieldReference field) {

      if (DEBUG) {
        Trace.guardedPrintln("visitPut " + field, DEBUG_METHOD_SUBSTRING);
      }

      // skip putfields of primitive type
      if (field.getFieldType().isPrimitiveType()) {
        return;
      }
      IField f = getClassHierarchy().resolveField(field);
      if (f == null) {
        if (DEBUG) {
          Trace.guardedPrintln("Could not resolve field " + field, DEBUG_METHOD_SUBSTRING);
        }
        getWarnings().add(FieldResolutionFailure.create(field));
        return;
      }
      if (Assertions.verifyAssertions) {
        Assertions._assert(isStatic || !symbolTable.isStringConstant(ref), "put to string constant shouldn't be allowed?");
      }
      if (isStatic) {
        processPutStatic(rval, field, f);
      } else {
        processPutField(rval, ref, f);
      }
    }

    private void processPutField(int rval, int ref, IField f) {
      if (Assertions.verifyAssertions) {
        Assertions._assert(!f.getFieldTypeReference().isPrimitiveType());
      }
      PointerKey refKey = getPointerKeyForLocal(node, ref);
      PointerKey rvalKey = getPointerKeyForLocal(node, rval);
      // if (!supportFullPointerFlowGraph &&
      // contentsAreInvariant(rval)) {
      if (contentsAreInvariant(symbolTable, du, rval)) {
        system.recordImplicitPointsToSet(rvalKey);
        InstanceKey[] ik = getInvariantContents(symbolTable, du, node, rval, SSAPropagationCallGraphBuilder.this);
        if (contentsAreInvariant(symbolTable, du, ref)) {
          system.recordImplicitPointsToSet(refKey);
          InstanceKey[] refk = getInvariantContents(symbolTable, du, node, ref, SSAPropagationCallGraphBuilder.this);
          for (int j = 0; j < refk.length; j++) {
            system.findOrCreateIndexForInstanceKey(refk[j]);
            PointerKey p = getPointerKeyForInstanceField(refk[j], f);
            for (int i = 0; i < ik.length; i++) {
              system.newConstraint(p, ik[i]);
            }
          }
        } else {
          for (int i = 0; i < ik.length; i++) {
            system.findOrCreateIndexForInstanceKey(ik[i]);
            system.newSideEffect(new InstancePutFieldOperator(f, ik[i]), refKey);
          }
        }
      } else {
        if (contentsAreInvariant(symbolTable, du, ref)) {
          system.recordImplicitPointsToSet(refKey);
          InstanceKey[] refk = getInvariantContents(symbolTable, du, node, ref, SSAPropagationCallGraphBuilder.this);
          for (int j = 0; j < refk.length; j++) {
            system.findOrCreateIndexForInstanceKey(refk[j]);
            PointerKey p = getPointerKeyForInstanceField(refk[j], f);
            system.newConstraint(p, assignOperator, rvalKey);
          }
        } else {
          if (DEBUG) {
            Trace.guardedPrintln("adding side effect " + f, DEBUG_METHOD_SUBSTRING);
          }
          system.newSideEffect(new PutFieldOperator(f, system.findOrCreatePointsToSet(rvalKey)), refKey);
        }
      }
    }

    private void processPutStatic(int rval, FieldReference field, IField f) {
      PointerKey fKey = getPointerKeyForStaticField(f);
      PointerKey rvalKey = getPointerKeyForLocal(node, rval);

      // if (!supportFullPointerFlowGraph &&
      // contentsAreInvariant(rval)) {
      if (contentsAreInvariant(symbolTable, du, rval)) {
        system.recordImplicitPointsToSet(rvalKey);
        InstanceKey[] ik = getInvariantContents(symbolTable, du, node, rval, SSAPropagationCallGraphBuilder.this);
        for (int i = 0; i < ik.length; i++) {
          system.newConstraint(fKey, ik[i]);
        }
      } else {
        system.newConstraint(fKey, assignOperator, rvalKey);
      }
      if (DEBUG) {
        Trace.guardedPrintln("visitPut class init " + field.getDeclaringClass() + " " + field, DEBUG_METHOD_SUBSTRING);
      }
      // side effect of putstatic: may call class initializer
      IClass klass = getClassHierarchy().lookupClass(field.getDeclaringClass());
      if (klass == null) {
        getWarnings().add(FieldResolutionFailure.create(field));
      } else {
        processClassInitializer(klass);
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.Instruction.Visitor#visitInvoke(com.ibm.wala.ssa.InvokeInstruction)
     */
    public void visitInvoke(SSAInvokeInstruction instruction) {
      visitInvokeInternal(instruction);
    }

    protected void visitInvokeInternal(SSAAbstractInvokeInstruction instruction) {
      if (DEBUG && debug) {
        Trace.println("visitInvoke: " + instruction);
      }

      PointerKey uniqueCatch = null;
      if (hasUniqueCatchBlock(instruction, ir)) {
        uniqueCatch = getUniqueCatchKey(instruction, ir, node);
      }

      if (instruction.getCallSite().isStatic()) {
        CGNode n = getTargetForCall(node, instruction.getCallSite(), (InstanceKey) null);
        if (n == null) {
          getWarnings().add(ResolutionFailure.create(node, instruction));
        } else {
          processResolvedCall(node, instruction, n, computeInvariantParameters(instruction), uniqueCatch);
          if (DEBUG) {
            Trace.guardedPrintln("visitInvoke class init " + n, DEBUG_METHOD_SUBSTRING);
          }

          // side effect of invoke: may call class initializer
          processClassInitializer(n.getMethod().getDeclaringClass());
        }
      } else {
        // Add a side effect that will fire when we determine a value
        // for the receiver. This side effect will create a new node
        // and new constraints based on the new callee context.
        // NOTE: This will not be adequate for CPA-style context selectors,
        // where the callee context may depend on state other than the
        // receiver. TODO: rectify this when needed.
        PointerKey receiver = getPointerKeyForLocal(node, instruction.getReceiver());
        // if (!supportFullPointerFlowGraph &&
        // contentsAreInvariant(instruction.getReceiver())) {
        if (contentsAreInvariant(symbolTable, du, instruction.getReceiver())) {
          system.recordImplicitPointsToSet(receiver);
          InstanceKey[] ik = getInvariantContents(symbolTable, du, node, instruction.getReceiver(),
              SSAPropagationCallGraphBuilder.this);
          for (int i = 0; i < ik.length; i++) {
            system.findOrCreateIndexForInstanceKey(ik[i]);
            CGNode n = getTargetForCall(node, instruction.getCallSite(), ik[i]);
            if (n == null) {
              getWarnings().add(ResolutionFailure.create(node, instruction));
            } else {
              processResolvedCall(node, instruction, n, computeInvariantParameters(instruction), uniqueCatch);
              // side effect of invoke: may call class initializer
              processClassInitializer(n.getMethod().getDeclaringClass());
            }
          }
        } else {
          if (DEBUG && debug) {
            Trace.println("Add side effect, dispatch to " + instruction + ", receiver " + receiver);
          }
          DispatchOperator dispatchOperator = new DispatchOperator(instruction, node, computeInvariantParameters(instruction),
              uniqueCatch);
          system.newSideEffect(dispatchOperator, receiver);
        }
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.Instruction.Visitor#visitNew(com.ibm.wala.ssa.NewInstruction)
     */
    public void visitNew(SSANewInstruction instruction) {
      InstanceKey iKey = getInstanceKeyForAllocation(node, instruction.getNewSite());
      if (iKey == null) {
        // something went wrong. I hope someone raised a warning.
        return;
      }
      PointerKey def = getPointerKeyForLocal(node, instruction.getDef());
      IClass klass = iKey.getConcreteType();

      if (DEBUG && debug) {
        Trace.println("visitNew: " + instruction + " " + iKey + " " + system.findOrCreateIndexForInstanceKey(iKey));
      }

      if (klass == null) {
        getWarnings().add(ResolutionFailure.create(node, instruction.getConcreteType()));
        return;
      }

      if (!contentsAreInvariant(symbolTable, du, instruction.getDef())) {
        system.newConstraint(def, iKey);
      } else {
        system.findOrCreateIndexForInstanceKey(iKey);
        system.recordImplicitPointsToSet(def);
      }

      // side effect of new: may call class initializer
      if (DEBUG) {
        Trace.guardedPrintln("visitNew call clinit: " + klass, DEBUG_METHOD_SUBSTRING);
      }
      processClassInitializer(klass);

      // add instance keys and pointer keys for array contents
      int dim = 0;
      InstanceKey lastInstance = iKey;
      while (klass != null && klass.isArrayClass()) {
        klass = ((ArrayClass) klass).getElementClass();
        // klass == null means it's a primitive
        if (klass != null && klass.isArrayClass()) {

          if (instruction.getNumberOfUses() <= (dim + 1)) {
            break;
          }
          int sv = instruction.getUse(dim + 1);
          if (ir.getSymbolTable().isIntegerConstant(sv)) {
            Integer c = (Integer) ir.getSymbolTable().getConstantValue(sv);
            if (c.intValue() == 0) {
              break;
            }
          }
          InstanceKey ik = getInstanceKeyForMultiNewArray(node, instruction.getNewSite(), dim);
          PointerKey pk = getPointerKeyForArrayContents(lastInstance);
          if (DEBUG_MULTINEWARRAY) {
            Trace.println("multinewarray constraint: ");
            Trace.println("   pk: " + pk);
            Trace.println("   ik: " + system.findOrCreateIndexForInstanceKey(ik) + " concrete type " + ik.getConcreteType()
                + " is " + ik);
            Trace.println("   klass:" + klass);
          }
          system.newConstraint(pk, ik);
          lastInstance = ik;
          dim++;
        }
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.Instruction.Visitor#visitThrow(com.ibm.wala.ssa.ThrowInstruction)
     */
    public void visitThrow(SSAThrowInstruction instruction) {
      // don't do anything: we handle exceptional edges
      // in a separate pass
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.Instruction.Visitor#visitGetCaughtException(com.ibm.wala.ssa.GetCaughtExceptionInstruction)
     */
    public void visitGetCaughtException(SSAGetCaughtExceptionInstruction instruction) {
      List<ProgramCounter> peis = getIncomingPEIs(ir, getBasicBlock());
      PointerKey def = getPointerKeyForLocal(node, instruction.getDef());
      // SJF: we don't optimize based on dead catch blocks yet ... it's a little
      // tricky due interaction with the SINGLE_USE optimization which directly
      // shoves exceptional return values from calls into exception vars.
      // it may not be worth doing this.
      // if (hasNoInterestingUses(instruction.getDef(), du)) {
      // solver.recordImplicitPointsToSet(def);
      // } else {
      Set types = getCaughtExceptionTypes(instruction, ir);
      addExceptionDefConstraints(ir, du, node, peis, def, types);
      // }
    }

    private int booleanConstantTest(SSAConditionalBranchInstruction c, int v) {
      int result = 0;

      // right for OPR_eq
      if ((symbolTable.isZeroOrFalse(c.getUse(0)) && c.getUse(1) == v)
          || (symbolTable.isZeroOrFalse(c.getUse(1)) && c.getUse(0) == v)) {
        result = -1;
      } else if ((symbolTable.isOneOrTrue(c.getUse(0)) && c.getUse(1) == v)
          || (symbolTable.isOneOrTrue(c.getUse(1)) && c.getUse(0) == v)) {
        result = 1;
      }

      if (c.getOperator() == ConditionalBranchInstruction.Operator.NE) {
        result = -result;
      }

      return result;
    }

    private int nullConstantTest(SSAConditionalBranchInstruction c, int v) {
      if ((symbolTable.isNullConstant(c.getUse(0)) && c.getUse(1) == v)
          || (symbolTable.isNullConstant(c.getUse(1)) && c.getUse(0) == v)) {
        if (c.getOperator() == ConditionalBranchInstruction.Operator.EQ) {
          return 1;
        } else {
          return -1;
        }
      } else {
        return 0;
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ssa.SSAInstruction.Visitor#visitPi(com.ibm.wala.ssa.SSAPiInstruction)
     */
    public void visitPi(SSAPiInstruction instruction) {
      int dir;
      ControlFlowGraph CFG = ir.getControlFlowGraph();
      PointerKey src = getPointerKeyForLocal(node, instruction.getVal());
      if (hasNoInterestingUses(instruction.getDef(), du)) {
        PointerKey dst = getPointerKeyForLocal(node, instruction.getDef());
        system.recordImplicitPointsToSet(dst);
      } else {
        if (com.ibm.wala.cfg.Util.endsWithConditionalBranch(CFG, getBasicBlock()) && CFG.getSuccNodeCount(getBasicBlock()) == 2) {
          SSAConditionalBranchInstruction cond = (SSAConditionalBranchInstruction) com.ibm.wala.cfg.Util.getLastInstruction(CFG,
              getBasicBlock());
          SSAInstruction cause = instruction.getCause();
          BasicBlock target = (BasicBlock) CFG.getNode(instruction.getSuccessor());
          if ((cause instanceof SSAInstanceofInstruction) && ((dir = booleanConstantTest(cond, cause.getDef())) != 0)) {
            TypeReference type = ((SSAInstanceofInstruction) cause).getCheckedType();
            IClass cls = cha.lookupClass(type);
            if (cls == null) {
              getWarnings().add(ResolutionFailure.create(node, type));
              PointerKey dst = getPointerKeyForLocal(node, instruction.getDef());
              system.newConstraint(dst, assignOperator, src);
            } else {
              PointerKey dst = getFilteredPointerKeyForLocal(node, instruction.getDef(), cls);
              if ((target == com.ibm.wala.cfg.Util.getTrueSuccessor(CFG, getBasicBlock()) && dir == 1)
                  || (target == com.ibm.wala.cfg.Util.getFalseSuccessor(CFG, getBasicBlock()) && dir == -1)) {
                system.newConstraint(dst, filterOperator, src);
                // System.err.println("PI " + dst + " " + src);
              } else {
                system.newConstraint(dst, inverseFilterOperator, src);
              }
            }
          } else if ((dir = nullConstantTest(cond, instruction.getVal())) != 0) {
            if ((target == com.ibm.wala.cfg.Util.getTrueSuccessor(CFG, getBasicBlock()) && dir == -1)
                || (target == com.ibm.wala.cfg.Util.getFalseSuccessor(CFG, getBasicBlock()) && dir == 1)) {
              PointerKey dst = getPointerKeyForLocal(node, instruction.getDef());
              system.newConstraint(dst, assignOperator, src);
            }
          } else {
            PointerKey dst = getPointerKeyForLocal(node, instruction.getDef());
            system.newConstraint(dst, assignOperator, src);
          }
        } else {
          PointerKey dst = getPointerKeyForLocal(node, instruction.getDef());
          system.newConstraint(dst, assignOperator, src);
        }
      }
    }

    public IBasicBlock getBasicBlock() {
      return basicBlock;
    }

    /**
     * The calling loop must call this in each iteration!
     */
    public void setBasicBlock(IBasicBlock block) {
      basicBlock = block;
    }

    /**
     * Side effect: records invariant parameters as implicit points-to-sets.
     * 
     * @return if non-null, then result[i] holds the set of instance keys which
     *         may be passed as the ith parameter. (which must be invariant)
     */
    protected InstanceKey[][] computeInvariantParameters(SSAAbstractInvokeInstruction call) {
      InstanceKey[][] constParams = null;
      for (int i = 0; i < call.getNumberOfUses(); i++) {
        // not sure how getUse(i) <= 0 .. dead code?
        // TODO: investigate
        if (call.getUse(i) > 0) {
          if (contentsAreInvariant(symbolTable, du, call.getUse(i))) {
            system.recordImplicitPointsToSet(getPointerKeyForLocal(node, call.getUse(i)));
            if (constParams == null) {
              constParams = new InstanceKey[call.getNumberOfUses()][];
            }
            constParams[i] = getInvariantContents(symbolTable, du, node, call.getUse(i), SSAPropagationCallGraphBuilder.this);
            for (int j = 0; j < constParams[i].length; j++) {
              system.findOrCreateIndexForInstanceKey(constParams[i][j]);
            }
          }
        }
      }
      return constParams;
    }

    public void visitLoadClass(SSALoadClassInstruction instruction) {
      PointerKey def = getPointerKeyForLocal(node, instruction.getDef());
      InstanceKey iKey = getInstanceKeyForClassObject(instruction.getLoadedClass());

      if (!contentsAreInvariant(symbolTable, du, instruction.getDef())) {
        system.newConstraint(def, iKey);
      } else {
        system.findOrCreateIndexForInstanceKey(iKey);
        system.recordImplicitPointsToSet(def);
      }
    }
  }

  /**
   * An operator to fire when we discover a potential new callee for a virtual
   * or interface call site.
   * 
   * This operator will create a new callee context and constraints if
   * necessary.
   * 
   * N.B: This implementation assumes that the calling context depends solely on
   * the dataflow information computed for the receiver. TODO: generalize this
   * to have other forms of context selection, such as CPA-style algorithms.
   */
  final class DispatchOperator extends UnaryOperator implements IPointerOperator {
    private final SSAAbstractInvokeInstruction call;

    private final ExplicitCallGraph.ExplicitNode node;

    private final InstanceKey[][] constParams;

    private final PointerKey uniqueCatch;

    /**
     * @param call
     * @param node
     * @param constParams
     *          if non-null, then constParams[i] holds the String constant that
     *          is passed as param i, or null if param i is not a String
     *          constant
     */
    DispatchOperator(SSAAbstractInvokeInstruction call, ExplicitCallGraph.ExplicitNode node, InstanceKey[][] constParams,
        PointerKey uniqueCatch) {
      this.call = call;
      this.node = node;
      this.constParams = constParams;
      this.uniqueCatch = uniqueCatch;
    }

    /**
     * The set of pointers that have already been processed.
     */
    private MutableIntSet previousReceivers = IntSetUtil.getDefaultIntSetFactory().make();

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.dataflow.fixpoint.UnaryOperator#evaluate(com.ibm.wala.dataflow.fixpoint.IVariable,
     *      com.ibm.wala.dataflow.fixpoint.IVariable)
     */
    public byte evaluate(IVariable lhs, IVariable rhs) {
      final IntSetVariable receivers = (IntSetVariable) rhs;
      final MutableBoolean sideEffect = new MutableBoolean();

      // compute the set of pointers that were not previously handled
      IntSet value = receivers.getValue();
      if (value == null) {
        // this constraint was put on the work list, probably by
        // initialization,
        // even though the right-hand-side is empty.
        // TODO: be more careful about what goes on the worklist to
        // avoid this.
        if (DEBUG) {
          Trace.println("EVAL dispatch with value null");
        }
        return NOT_CHANGED;
      }
      if (DEBUG) {
        Trace.println("EVAL dispatch to " + node + ":" + call);
        Trace.println("receivers: " + value);
      }

      IntSetAction action = new IntSetAction() {
        public void act(int ptr) {
          if (DEBUG) {
            Trace.println("    dispatch to ptr " + ptr);
          }
          InstanceKey iKey = system.getInstanceKey(ptr);
          TypeReference concreteType = iKey.getConcreteType().getReference();
          // skip malleable
          if (Malleable.isMalleable(concreteType)) {
            return;
          }
          CGNode target;

          if (clone2Assign) {
            // for efficiency: assume that only call sites that reference
            // clone() might dispatch to clone methods
            if (call.getCallSite().getDeclaredTarget().getSelector().equals(cloneSelector)) {
              IClass recv = (iKey != null) ? iKey.getConcreteType() : null;
              IMethod targetMethod = options.getMethodTargetSelector().getCalleeTarget(node, call.getCallSite(), recv);
              if (targetMethod != null && targetMethod.getReference().equals(CloneInterpreter.CLONE)) {
                // treat this call to clone as an assignment
                PointerKey result = getPointerKeyForLocal(node, call.getDef());
                PointerKey receiver = getPointerKeyForLocal(node, call.getReceiver());
                system.newConstraint(result, assignOperator, receiver);
                return;
              }
            }
          }

          target = getTargetForCall(node, call.getSite(), iKey);

          if (target == null) {
            // This indicates an error; I sure hope getTargetForCall
            // raised a warning about this!
            if (DEBUG) {
              Trace.println("Warning: null target for call " + call + " " + iKey);
            }
          } else {
            IntSet targets = node.getPossibleTargetNumbers(call.getCallSite());
            if (targets != null && targets.contains(target.getGraphNodeId())) {
              // do nothing; we've previously discovered and handled this
              // receiver for this call site.
            } else {
              // process the newly discovered target for this call
              sideEffect.b = true;
              processResolvedCall(node, call, target, constParams, uniqueCatch);
              if (!haveAlreadyVisited(target)) {
                markDiscovered(target);
              }
            }
          }
        }
      };

      try {
        value.foreachExcluding(previousReceivers, action);
      } catch (Error e) {
        System.err.println("error in " + call + " on " + receivers + " of types " + value + " for " + node);
        throw e;
      } catch (RuntimeException e) {
        System.err.println("error in " + call + " on " + receivers + " of types " + value + " for " + node);
        throw e;
      }

      // update the set of receivers previously considered
      previousReceivers.copySet(value);

      byte sideEffectMask = sideEffect.b ? (byte) SIDE_EFFECT_MASK : 0;
      if (willNeverChangeAgain(value)) {
        return (byte) (NOT_CHANGED_AND_FIXED | sideEffectMask);
      } else {
        return (byte) (NOT_CHANGED | sideEffectMask);
      }
    }

    /**
     * @return true iff we never have to eval this dispatch operator again
     */
    private boolean willNeverChangeAgain(IntSet receivers) {
      int bound = getBoundOnNumberOfTargets(node, call.getSite());
      if (bound > -1) {
        int nTargets = node.getNumberOfTargets(call.getSite());
        if (Assertions.verifyAssertions) {
          if (nTargets > bound) {
            Trace.println("node: " + node);
            Trace.println("site: " + call.getSite());
            Trace.println("instruction " + call);
            Trace.println("nTargets: " + nTargets);
            Trace.println("bound:    " + bound);
            for (Iterator it = node.getPossibleTargets(call.getSite()).iterator(); it.hasNext();) {
              Trace.println("  " + it.next());
            }
            for (IntIterator intIt = receivers.intIterator(); intIt.hasNext();) {
              InstanceKey ik = system.getInstanceKey(intIt.next());
              Trace.println("Receiver " + ik);
            }
            Assertions._assert(false, "see tracefile");
          }
        }
        if (nTargets == bound) {
          return true;
        }
      }
      return false;
    }

    public String toString() {
      return "Dispatch to " + call + " in node " + node;
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.dataflow.Operator#hashCode()
     */
    public int hashCode() {
      return node.hashCode() + 90289 * call.hashCode();
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.dataflow.Operator#equals(java.lang.Object)
     */
    public boolean equals(Object o) {
      // note that these are not necessarily canonical, since
      // with synthetic factories we may regenerate constraints
      // many times. TODO: change processing of synthetic factories
      // so that we guarantee to insert each dispatch equation
      // only once ... if this were true we could optimize this
      // with reference equality

      // instanceof is OK because this class is final
      if (o instanceof DispatchOperator) {
        DispatchOperator other = (DispatchOperator) o;
        return node.equals(other.node) && call.equals(other.call);
      } else {
        return false;
      }
    }

    /*
     * (non-Javadoc)
     * 
     * @see com.ibm.wala.ipa.callgraph.propagation.IPointerOperator#isComplex()
     */
    public boolean isComplex() {
      return true;
    }
  }

  /**
   * Add constraints for a call site after we have computed a reachable target
   * for the dispatch
   * 
   * Side effect: add edge to the call graph.
   * 
   * @param instruction
   * @param constParams
   *          if non-null, then constParams[i] holds the set of instance keys
   *          that are passed as param i, or null if param i is not invariant
   * @param uniqueCatchKey
   *          if non-null, then this is the unique PointerKey that catches all
   *          exceptions from this call site.
   */
  private void processResolvedCall(CGNode caller, SSAAbstractInvokeInstruction instruction, CGNode target,
      InstanceKey[][] constParams, PointerKey uniqueCatchKey) {

    if (DEBUG) {
      Trace.println("processResolvedCall: " + caller + " ," + instruction + " , " + target);
    }

    if (DEBUG) {
      Trace.println("addTarget: " + caller + " ," + instruction + " , " + target);
    }
    caller.addTarget(instruction.getCallSite(), target);

    if (FakeRootMethod.isFakeRootMethod(caller.getMethod().getReference())) {
      if (entrypointCallSites.contains(instruction.getSite())) {
        callGraph.registerEntrypoint(target);
      }
    }

    if (!haveAlreadyVisited(target)) {
      markDiscovered(target);
    }

    // TODO: i'd like to enable this optimization, but it's a little tricky
    // to recover the implicit points-to sets with recursion. TODO: don't
    // be lazy and code the recursive logic to enable this.
    // if (hasNoInstructions(target)) {
    // // record points-to sets for formals implicitly .. computed on
    // // demand.
    // // TODO: generalize this by using hasNoInterestingUses on parameters.
    // // however .. have to be careful to cache results in that case ... don't
    // // want
    // // to recompute du each time we process a call to Object.<init> !
    // for (int i = 0; i < instruction.getNumberOfUses(); i++) {
    // // we rely on the invariant that the value number for the ith parameter
    // // is i+1
    // final int vn = i + 1;
    // PointerKey formal = getPointerKeyForLocal(target, vn);
    // if (target.getMethod().getParameterType(i).isReferenceType()) {
    // system.recordImplicitPointsToSet(formal);
    // }
    // }
    // } else {
    // generate contraints from parameter passing
    int nUses = instruction.getNumberOfParameters();
    int nExpected = target.getMethod().getNumberOfParameters();

    /*
     * int nExpected =
     * target.getMethod().getReference().getNumberOfParameters(); if
     * (!target.getMethod().isStatic() && !target.getMethod().isClinit()) {
     * nExpected++; }
     */

    if (nUses != nExpected) {
      // some sort of unverifiable code mismatch. give up.
      getWarnings().add(ResolutionFailure.create(target, instruction, "found " + nUses + " uses but expected " + nExpected));
      return;
    }

    boolean needsFilter = !instruction.getSite().isStatic() && needsFilterForReceiver(instruction, target);
    // we're a little sloppy for now ... we don't filter calls to
    // java.lang.Object.
    // TODO: we need much more precise filters than cones in order to handle
    // the various types of dispatch logic. We need a filter that expresses
    // "the set of types s.t. x.foo resolves to y.foo."
    for (int i = 0; i < instruction.getNumberOfParameters(); i++) {
      // we rely on the invariant that the value number for the ith parameter
      // is i+1
      final int vn = i + 1;

      if (target.getMethod().getParameterType(i).isReferenceType()) {
        // if (constParams != null && constParams[i] != null &&
        // !supportFullPointerFlowGraph) {
        if (constParams != null && constParams[i] != null) {
          InstanceKey[] ik = constParams[i];
          for (int j = 0; j < ik.length; j++) {
            if (needsFilter && (i == 0)) {
              FilteredPointerKey.TypeFilter C = getFilter(target);
              PointerKey formal = null;
              if (isRootType(C)) {
                // TODO: we need much better filtering here ... see comments
                // above.
                formal = getPointerKeyForLocal(target, vn);
              } else {
                formal = getFilteredPointerKeyForLocal(target, vn, C);
              }
              system.newConstraint(formal, ik[j]);
            } else {
              PointerKey formal = getPointerKeyForLocal(target, vn);
              system.newConstraint(formal, ik[j]);
            }
          }
        } else {
          if (Assertions.verifyAssertions) {
            if (instruction.getUse(i) < 0) {
              Assertions.UNREACHABLE("unexpected " + instruction + " in " + caller);
            }
          }
          PointerKey actual = getPointerKeyForLocal(caller, instruction.getUse(i));
          if (needsFilter && (i == 0)) {
            FilteredPointerKey.TypeFilter C = getFilter(target);
            if (isRootType(C)) {
              // TODO: we need much better filtering here ... see comments
              // above.
              PointerKey formal = getPointerKeyForLocal(target, vn);
              system.newConstraint(formal, assignOperator, actual);
            } else {
              FilteredPointerKey formal = getFilteredPointerKeyForLocal(target, vn, C);
              system.newConstraint(formal, filterOperator, actual);
            }
          } else {
            PointerKey formal = getPointerKeyForLocal(target, vn);
            system.newConstraint(formal, assignOperator, actual);
          }
        }
      }
    }

    // generate contraints from return value.
    if (instruction.hasDef() && instruction.getDeclaredResultType().isReferenceType()) {
      PointerKey result = getPointerKeyForLocal(caller, instruction.getDef());
      PointerKey ret = getPointerKeyForReturnValue(target);
      system.newConstraint(result, assignOperator, ret);
    }
    // generate contraints from exception return value.
    PointerKey e = getPointerKeyForLocal(caller, instruction.getException());
    PointerKey er = getPointerKeyForExceptionalReturnValue(target);
    if (SHORT_CIRCUIT_SINGLE_USES && uniqueCatchKey != null) {
      // e has exactly one use. so, represent e implicitly
      system.newConstraint(uniqueCatchKey, assignOperator, er);
    } else {
      system.newConstraint(e, assignOperator, er);
    }
    // }
  }

  public boolean hasNoInterestingUses(int vn, DefUse du) {

    if (du == null) {
      throw new IllegalArgumentException("du is null");
    }
    // todo: enhance this by solving a dead-code elimination
    // problem.
    InterestingVisitor v = makeInterestingVisitor(vn);
    for (Iterator it = du.getUses(vn); it.hasNext();) {
      SSAInstruction s = (SSAInstruction) it.next();
      s.visit(v);
      if (v.bingo) {
        return false;
      }
    }
    return true;
  }

  protected InterestingVisitor makeInterestingVisitor(int vn) {
    return new InterestingVisitor(vn);
  }

  /**
   * @author sfink sets bingo to true when it visits an interesting instruction
   */
  protected static class InterestingVisitor extends SSAInstruction.Visitor {
    protected final int vn;

    protected InterestingVisitor(int vn) {
      this.vn = vn;
    }

    protected boolean bingo = false;

    public void visitArrayLoad(SSAArrayLoadInstruction instruction) {
      if (!instruction.typeIsPrimitive() && instruction.getArrayRef() == vn) {
        bingo = true;
      }
    }

    public void visitArrayStore(SSAArrayStoreInstruction instruction) {
      if (!instruction.typeIsPrimitive() && (instruction.getArrayRef() == vn || instruction.getValue() == vn)) {
        bingo = true;
      }
    }

    public void visitCheckCast(SSACheckCastInstruction instruction) {
      bingo = true;
    }

    public void visitGet(SSAGetInstruction instruction) {
      FieldReference field = instruction.getDeclaredField();
      if (!field.getFieldType().isPrimitiveType()) {
        bingo = true;
      }
    }

    public void visitGetCaughtException(SSAGetCaughtExceptionInstruction instruction) {
      bingo = true;
    }

    public void visitInvoke(SSAInvokeInstruction instruction) {
      bingo = true;
    }

    public void visitPhi(SSAPhiInstruction instruction) {
      bingo = true;
    }

    public void visitPi(SSAPiInstruction instruction) {
      bingo = true;
    }

    public void visitPut(SSAPutInstruction instruction) {
      FieldReference field = instruction.getDeclaredField();
      if (!field.getFieldType().isPrimitiveType()) {
        bingo = true;
      }
    }

    public void visitReturn(SSAReturnInstruction instruction) {
      bingo = true;
    }

    public void visitThrow(SSAThrowInstruction instruction) {
      bingo = true;
    }
  }

  /**
   * TODO: enhance this logic using type inference
   * 
   * @param instruction
   * @return true if we need to filter the receiver type to account for virtual
   *         dispatch
   */
  private boolean needsFilterForReceiver(SSAAbstractInvokeInstruction instruction, CGNode target) {

    FilteredPointerKey.TypeFilter f = (FilteredPointerKey.TypeFilter) target.getContext().get(ContextKey.FILTER);

    if (f != null) {
      // the context selects a particular concrete type for the receiver.
      // we need to filter, unless the declared receiver type implies the
      // concrete type (TODO: need to implement this optimization)
      return true;
    }

    // don't need to filter for invokestatic
    if (instruction.getSite().isStatic() || instruction.getSite().isSpecial()) {
      return false;
    }

    MethodReference declaredTarget = instruction.getDeclaredTarget();
    IMethod resolvedTarget = getClassHierarchy().resolveMethod(declaredTarget);
    if (resolvedTarget == null) {
      // there's some problem that will be flagged as a warning
      return true;
    }
    if (isRootOfVirtualMethodHierarchy(resolvedTarget)) {
      int n = findOrCreateBoundFromClassHierarchy(resolvedTarget.getReference());
      if (n == 1) {
        // there is only one possible target method according to the class
        // hierarchy.
        // so, we don't need to filter, since all possible receiver objects
        // will flow
        // into the one target
        return false;
      }
    }
    return true;
  }

  private boolean isRootType(IClass klass) {
    return klass.getReference().equals(cha.getRootClass().getReference());
  }

  private boolean isRootType(FilteredPointerKey.TypeFilter filter) {
    if (filter instanceof FilteredPointerKey.SingleClassFilter) {
      return isRootType(((FilteredPointerKey.SingleClassFilter) filter).getConcreteType());
    } else {
      return false;
    }
  }

  /**
   * @return true iff m is the root of a virtual method hierarchy; ie., m does
   *         NOT override a method in the superclass.
   */
  private boolean isRootOfVirtualMethodHierarchy(IMethod im) {
    IClass declaringClass = im.getDeclaringClass();
    if (isRootType(declaringClass)) {
      return true;
    }
    IClass superClass = null;
    try {
      superClass = declaringClass.getSuperclass();
    } catch (ClassHierarchyException e) {
      Assertions.UNREACHABLE();
    }
    IMethod sm = getClassHierarchy().resolveMethod(superClass, im.getSelector());
    return (sm == null);
  }

  /**
   * TODO: enhance this logic using type inference TODO!!!: enhance filtering to
   * consider concrete types, not just cones. precondition: needs Filter
   * 
   * @param target
   * @return an IClass which represents
   */
  private FilteredPointerKey.TypeFilter getFilter(CGNode target) {
    FilteredPointerKey.TypeFilter filter = (FilteredPointerKey.TypeFilter) target.getContext().get(ContextKey.FILTER);

    if (filter != null) {
      return filter;
    } else {
      // the context does not select a particular concrete type for the
      // receiver.
      IClass C = getReceiverClass(target.getMethod());
      return new FilteredPointerKey.SingleClassFilter(C);
    }
  }

  /**
   * @param method
   * @return the receiver class for this method.
   */
  private IClass getReceiverClass(IMethod method) {
    TypeReference formalType = method.getParameterType(0);
    IClass C = getClassHierarchy().lookupClass(formalType);
    if (Assertions.verifyAssertions) {
      if (method.isStatic()) {
        Assertions.UNREACHABLE("asked for receiver of static method " + method);
      }
      if (C == null) {
        Assertions.UNREACHABLE("no class found for " + formalType + " recv of " + method);
      }
    }
    return C;
  }

  /**
   * A value is "invariant" if we can figure out the instances it can ever point
   * to locally, without resorting to propagation.
   * 
   * @param valueNumber
   * @return true iff the contents of the local with this value number can be
   *         deduced locally, without propagation
   */
  protected boolean contentsAreInvariant(SymbolTable symbolTable, DefUse du, int valueNumber) {
    if (isConstantRef(symbolTable, valueNumber)) {
      return true;
    } else if (SHORT_CIRCUIT_INVARIANT_SETS) {
      SSAInstruction def = du.getDef(valueNumber);
      if (def instanceof SSANewInstruction) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }

  /**
   * precondition:contentsAreInvariant(valueNumber)
   * 
   * @param valueNumber
   * @return the complete set of instances that the local with vn=valueNumber
   *         may point to.
   */
  protected InstanceKey[] getInvariantContents(SymbolTable symbolTable, DefUse du, CGNode node, int valueNumber, HeapModel hm) {
    return getInvariantContents(symbolTable, du, node, valueNumber, hm, false);
  }

  protected InstanceKey[] getInvariantContents(SymbolTable symbolTable, DefUse du, CGNode node, int valueNumber, HeapModel hm,
      boolean ensureIndexes) {
    InstanceKey[] result;
    if (isConstantRef(symbolTable, valueNumber)) {
      Object S = symbolTable.getConstantValue(valueNumber);
      InstanceKey ik = hm.getInstanceKeyForConstant(S);
      if (ik != null)
        result = new InstanceKey[] { ik };
      else
        result = new InstanceKey[0];
    } else {
      SSANewInstruction def = (SSANewInstruction) du.getDef(valueNumber);
      InstanceKey iKey = hm.getInstanceKeyForAllocation(node, def.getNewSite());
      result = (iKey == null) ? new InstanceKey[0] : new InstanceKey[] { iKey };
    }

    if (ensureIndexes) {
      for (int i = 0; i < result.length; i++) {
        system.findOrCreateIndexForInstanceKey(result[i]);
      }
    }

    return result;
  }

  protected boolean isConstantRef(SymbolTable symbolTable, int valueNumber) {
    if (valueNumber == -1) {
      return false;
    }
    if (symbolTable.isConstant(valueNumber)) {
      Object v = symbolTable.getConstantValue(valueNumber);
      return (!(v instanceof Number));
    } else {
      return false;
    }
  }

  /**
   * @author sfink
   * 
   * A warning for when we fail to resolve the type for a checkcast
   */
  private static class CheckcastFailure extends Warning {

    final TypeReference type;

    CheckcastFailure(TypeReference type) {
      super(Warning.SEVERE);
      this.type = type;
    }

    public String getMsg() {
      return getClass().toString() + " : " + type;
    }

    public static CheckcastFailure create(TypeReference type) {
      return new CheckcastFailure(type);
    }
  }

  /**
   * @author sfink
   * 
   * A warning for when we fail to resolve the type for a field
   */
  private static class FieldResolutionFailure extends Warning {

    final FieldReference field;

    FieldResolutionFailure(FieldReference field) {
      super(Warning.SEVERE);
      this.field = field;
    }

    public String getMsg() {
      return getClass().toString() + " : " + field;
    }

    public static FieldResolutionFailure create(FieldReference field) {
      return new FieldResolutionFailure(field);
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see com.ibm.wala.ipa.callgraph.propagation.HeapModel#iteratePointerKeys()
   */
  public Iterator iteratePointerKeys() {
    return system.iteratePointerKeys();
  }

  public static Set<TypeReference> getCaughtExceptionTypes(SSAGetCaughtExceptionInstruction instruction, IR ir) {
    if (ir == null) {
      throw new IllegalArgumentException("ir is null");
    }
    if (instruction == null) {
      throw new IllegalArgumentException("instruction is null");
    }
    Iterator<TypeReference> exceptionTypes = ((ExceptionHandlerBasicBlock) ir.getControlFlowGraph().getNode(
        instruction.getBasicBlockNumber())).getCaughtExceptionTypes();
    HashSet<TypeReference> types = HashSetFactory.make(10);
    for (; exceptionTypes.hasNext();) {
      types.add(exceptionTypes.next());
    }
    return types;
  }

  /*
   * (non-Javadoc)
   * 
   * @see com.ibm.wala.ipa.callgraph.propagation.InstanceKeyFactory#getInstanceKeyForPEI(com.ibm.wala.ipa.callgraph.CGNode,
   *      com.ibm.wala.classLoader.ProgramCounter,
   *      com.ibm.wala.types.TypeReference)
   */
  public InstanceKey getInstanceKeyForPEI(CGNode node, ProgramCounter instr, TypeReference type) {
    return getInstanceKeyForPEI(node, instr, type, instanceKeyFactory);
  }

  /*
   * (non-Javadoc)
   * 
   * @see com.ibm.wala.ipa.callgraph.propagation.PropagationCallGraphBuilder#makeSolver()
   */
  protected IPointsToSolver makeSolver() {
    return usePreTransitiveSolver ? (IPointsToSolver) new PreTransitiveSolver(system, this) : new StandardSolver(system, this);
    // return true ? (IPointsToSolver)new PreTransitiveSolver(system,this) : new
    // StandardSolver(system,this);
  }
}
