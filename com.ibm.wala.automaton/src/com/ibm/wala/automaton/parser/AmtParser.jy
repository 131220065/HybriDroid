/*
 * Automaton/Grammar/Pattern Parser
 * 
 * AmtParser.java is generated from this file by kmyacc
 * that is available at http://www005.upp.so-net.ne.jp/kmori/kmyacc/.
 *
 * See also doc/parser-guide.txt more in detials.
 */

%{
package com.ibm.capa.util.automaton.parser;

import java.io.*;
import java.nio.*;
import sun.io.*;
import java.util.*;
import java.lang.reflect.*;

import com.ibm.wala.automaton.*;
import com.ibm.wala.automaton.grammar.string.*;
import com.ibm.wala.automaton.grammar.tree.*;
import com.ibm.wala.automaton.regex.string.*;
import com.ibm.wala.automaton.regex.tree.*;
import com.ibm.wala.automaton.string.*;
import com.ibm.wala.automaton.tree.*;

%}

%token SYMBOL STRING VARIABLE DVARIABLE
%token AND OR EQ
%token INTEGER DOUBLE
%token STATE
%token ARROW
%token NEW
%token NULL
%token AS REF
/* 2006 10 16, tabee@jp.ibm.com */
%token CHARRANGE CHAR CHARSETEND

%token SEARCH ALIAS DELETE

%token TREEGRAMMAR

%type <String> SYMBOL STRING VARIABLE DVARIABLE
%type <Long> INTEGER
%type <Double> DOUBLE
%type <String> STATE
/* 2006 10 16, tabee@jp.ibm.com */
%type <Character[]> CHARRANGE
%type <Character> CHAR

%type <ITreeGrammar> TREEGRAMMAR

%type <Object> expression instantiation parameter
%type <IVariable> variable dvariable
%type <IBinaryTreeVariable> btvariable
%type <ISymbol> symbol basicSymbol
%type <IState> state
%type <List> expressions parameters symbols
%type <Map> propertyDefinition propertyDefinitions
%type <String> propertyName className classPath
%type <ITree> tree treeChild
%type <ITreeGrammar> treeGrammar
%type <Set> treeProductionRules
%type <IProductionRule> treeProductionRule
%type <List> treeChildren
%type <IBinaryTree> btree btreeChild
%type <IPattern> stringPattern stringPatternOrEmpty treePattern
%type <IPattern> charSet charSetOrComplementCharSet
%type <IPattern> stringPatternExpr

%left '='

%left EQ
%left OR AND
%left '+' '-'
%left '*' '/'

%left AS
%left '|', '&'
%right ','
%nonassoc '~', '*', '+', '?'


%%

start
: definitions
| expression  { result.put(lastVariable, $1); }
;

definitions
: definition definitions
| /* empty */
;

definition
: variable '=' expression enddef { result.put($1, $3); }
| DELETE variable { result.remove($2); }
| SEARCH classPath enddef { searchPath.add($2); }
| DELETE SEARCH classPath enddef { searchPath.remove($3); }
| ALIAS basicSymbol '=' symbol enddef { alias.put($2,$4); }
| DELETE ALIAS basicSymbol enddef { alias.remove($3); }
;

expression
: instantiation { $$ = $1; }
| instantiation '{' propertyDefinitions '}' {
        Object instance = $1;
        Map propDefs = $3;
        for (Iterator i = propDefs.keySet().iterator(); i.hasNext(); ) {
            String propName = (String) i.next();
            Object propValue = propDefs.get(propName);
            try {
                String setterName = "set" + Character.toUpperCase(propName.charAt(0)) + propName.substring(1);
                instance.getClass().getMethod(setterName, new Class[]{propValue.getClass()}).invoke(instance, new Object[]{propValue});
            } catch (NoSuchMethodException e) {
                try {
                    instance.getClass().getField(propName).set(instance, propValue);
                } catch (IllegalArgumentException e1) {
                    e1.printStackTrace();
                } catch (SecurityException e1) {
                    e1.printStackTrace();
                } catch (IllegalAccessException e1) {
                    e1.printStackTrace();
                } catch (NoSuchFieldException e1) {
                    e1.printStackTrace();
                }
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
            } catch (SecurityException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            }
        }
        $$ = instance;
  }
| '{' expressions '}' { $$ = new HashSet($2); }
| '[' expressions ']' { $$ = new ArrayList($2); }
| STRING { $$ = $1; }
| INTEGER { $$ = $1; }
| DOUBLE { $$ = $1; }
| symbol { $$ = $1; }
| state  { $$ = $1; }
| variable { $$ = result.get($1); }
| dvariable { $$ = $1; }
| tree   { $$ = $1; }
| btree  { $$ = $1; }
| stringPatternExpr { $$ = $1; }
| '%' '{' treePattern '}' { $$ = $3; }
| '(' expression ')' { $$ = $2; }
| treeGrammar { $$ = $1; }
;

stringPatternExpr
: '/' { inStringPattern = 0; } stringPatternOrEmpty { inStringPattern = -1; } '/' { $$ = $3; }
;

instantiation
: className '(' parameters ')' {
    String cname = $1;
    List params = $3;
    Class klasses[] = new Class[params.size()];
    Object objs[] = new Object[params.size()];
    for (ListIterator i = params.listIterator(); i.hasNext(); ) {
        int index = i.nextIndex();
        Object val = i.next();
        klasses[index] = val.getClass();
        objs[index] = val;
    }
    Object instance = null;
    for (Iterator i = searchPath.iterator(); i.hasNext(); ) {
      String path = (String) i.next();
      try {
          String fullcname = null;
          if (path == null || path.length() == 0) {
            fullcname = cname;
          }
          else if (path.charAt(path.length()-1) == '.') {
            fullcname = path + cname;
          }
          else {
            fullcname = path + "." + cname;
          }
          Class klass = CLASSLOADER.loadClass(fullcname);
          Constructor constructors[] = klass.getConstructors();
          for (int j = 0; j < constructors.length; j++) {
              try {
                  instance = constructors[j].newInstance(objs);
                  break;
              }
              catch(Exception e) {
                  if (j == constructors.length-1) {
                      throw(new RuntimeException(e));
                  }
              }
          }
          break;
      } catch (Exception e) {
          if(!i.hasNext()) {
              throw(new RuntimeException(e));
          }
      }
    }
    $$ = instance;
  }
;

expressions
: expression ',' expressions { List l = $3; l.add(0, $1); $$ = l; }
| expression    { List l = new ArrayList(); l.add(0, $1); $$ = l; }
| /* empty */   { $$ = new ArrayList(); }
;

tree
: symbol '[' treeChildren ']' { Tree t = new Tree($1, $3); $$ = t; }
;

treeChild
: tree { $$ = $1; }
| symbol   { Tree t = new Tree($1); $$ = t; }
| variable { $$ = result.get($1); }
| dvariable { $$ = new TreeVariable($1); }
;

treeChildren
: treeChild ',' treeChildren { List l = $3; l.add(0, $1); $$ = l; }
| treeChild     { List l = new ArrayList(); l.add($1); $$ = l; }
| /* empty */   { List l = new ArrayList(); $$ = l; }
;

btree
: symbol '[' btreeChild ';' btreeChild ']' { BinaryTree t = new BinaryTree($1, $3, $5); $$ = t; }
| stringPatternExpr '[' btreeChild ';' btreeChild ']' { BinaryTree t = new BinaryTree(new StringPatternSymbol($1), $3, $5); $$ = t; }
;

btreeChild
: btree { $$ = $1; }
| symbol { BinaryTree t = new BinaryTree($1); $$ = t; }
| variable { $$ = result.get($1); }
| dvariable { $$ = new BinaryTreeVariable($1); }
| NULL        { $$ = null; }
| stringPatternExpr { BinaryTree t = new BinaryTree(new StringPatternSymbol($1)); $$ = t; }
| /* empty */ { $$ = null; }
;

stringPattern
: symbol { $$ = new SymbolPattern($1); }
| stringPattern ',' stringPattern { $$ = new ConcatenationPattern($1, $3); }
| stringPattern ',' { $$ = $1; }
| stringPattern '*' { $$ = new IterationPattern($1, true); }
| stringPattern '+' { $$ = new IterationPattern($1, false); }
| stringPattern '?' { $$ = new UnionPattern($1, new EmptyPattern()); }
| stringPattern '|' stringPattern { $$ = new UnionPattern($1,$3); }
| stringPattern '&' stringPattern { $$ = new IntersectionPattern($1,$3); }
| stringPattern '-' stringPattern { $$ = new IntersectionPattern($1, new ComplementPattern($3)); }
| '~' stringPattern { $$ = new ComplementPattern($2); }
| '(' { inStringPattern++; varStack.push(new Variable(Integer.toString(inStringPattern))); } stringPatternOrEmpty ')' { $$ = new VariableBindingPattern($3, (IVariable)varStack.pop()); }
/* 2006 10 16, tabee@jp.ibm.com Begin */
| '[' { inCharSetPattern++; charSetBegin = true; isComplementCharSet = false; } charSetOrComplementCharSet {
		inCharSetPattern--;
		$$ = $3;
	}
;

charSetOrComplementCharSet
: '^' charSet {	$$ = new IntersectionPattern(new SymbolPattern(new CharPatternSymbol("\\.")), new ComplementPattern($2)); }
| charSet { $$ = $1; }

charSet
:
| CHARRANGE CHARSETEND {
		$$ = charRange((Character[])$1);
	}
| CHARRANGE charSet {
		IPattern p1 = charRange((Character[])$1);
		$$ = new UnionPattern(p1, $2);
	}
| CHAR CHARSETEND { Character c = (Character)$1; $$ = new SymbolPattern(new CharSymbol(c.charValue())); }
| CHAR charSet {
		Character c = (Character)$1; 
		IPattern p1 = new SymbolPattern(new CharSymbol(c.charValue()));	
		$$= new UnionPattern(p1, $2);
	}
/* 2006 10 16, tabee@jp.ibm.com End */

stringPatternOrEmpty
: stringPattern { $$ = $1; }
| /* empty */ { $$ = new EmptyPattern(); }
;

treePattern
: symbol { $$ = new SymbolPattern($1); }
| '(' ')' { $$ = new EmptyPattern(); }
| treePattern '*' { $$ = new IterationPattern($1, true); }
| treePattern '+' { $$ = new IterationPattern($1, false); }
| treePattern ',' treePattern { $$ = new ConcatenationPattern($1, $3); }
| treePattern '|' treePattern { $$ = new UnionPattern($1,$3); }
| treePattern AS variable { $$ = new VariableBindingPattern($1,$3); }
| REF variable { $$ = new VariableReferencePattern($2); }
| REF '(' variable ')' { $$ = new VariableReferencePattern($3); }
| '~' treePattern { $$ = new ComplementPattern($2); }
| '(' treePattern ')' { $$ = $2; }
;

treeGrammar
: TREEGRAMMAR btvariable '{' treeProductionRules '}' { $$ = new TreeGrammar($2, $4); }
;

btvariable
: dvariable { $$ = new BinaryTreeVariable($1); }
;

treeProductionRules
: treeProductionRule treeProductionRules { Set rules = $2; rules.add($1); $$ = rules; }
| /* empty */ { $$ = new HashSet(); }
;

treeProductionRule
: btvariable ARROW btree enddef { $$ = new ProductionRule($1, $3); }
| btvariable ARROW variable enddef { $$ = new ProductionRule($1, (IBinaryTree)result.get($3)); }
| btvariable ARROW NULL enddef  { $$ = new ProductionRule($1, BinaryTree.LEAF); }
| btvariable ARROW enddef  { $$ = new ProductionRule($1, BinaryTree.LEAF); }
;

propertyDefinitions
: propertyDefinition propertyDefinitions {
    Map m1 = $1;
    Map m2 = $2;
    for (Iterator i = m1.keySet().iterator(); i.hasNext(); ) {
        Object key = i.next();
        Object val = m1.get(key);
        m2.put(key, val);
    }
    $$ = m2;
  }
| /* empty */ { $$ = new HashMap(); }
;

propertyDefinition
: propertyName '=' expression {
    Map m = new HashMap();
    m.put($1, $3);
    $$ = m;
  }
;

propertyName
: SYMBOL { $$ = $1; }
;

className
: classPath { $$ = $1; }
;

classPath
: symbol { $$ = $1.getName(); }
| symbol '.' classPath { $$ = $1.getName() + "." + $3; }
| STRING { $$ = $1; }
;

parameters
: parameter ',' parameters { List l = $3; l.add(0, $1); $$ = l; }
| parameter   { List l = new ArrayList(); l.add(0, $1); $$ = l; }
| /* empty */ { $$ = new ArrayList(); }
;

parameter
: expression { $$ = $1; }
;

variable
: VARIABLE { $$ = new Variable($1); }
;

dvariable
: DVARIABLE { $$ = new Variable($1); }
;

symbols
: symbol ',' symbols { $3.add(0, $1); $$ = $3; }
| symbol             { List l = new LinkedList(); l.add($1); $$ = l; }
;

symbol
: basicSymbol {
    ISymbol s = $1;
    if (alias.containsKey(s)) {
      s = (ISymbol) alias.get(s);
    }
    $$ = s;
  }
;

basicSymbol
: SYMBOL {
    String s = $1;
    if (inStringPattern >= 0) {
      if (s.charAt(0) == '\\' && s.length() > 1) {
        $$ = new CharPatternSymbol(s);
      }
      else {
        $$ = new CharSymbol(s);
      }
    }
    else {
      $$ = new StringSymbol(s);
    }
  }
| SYMBOL ':' symbol { $$ = new PrefixedSymbol(new StringSymbol($1), $3); }
;

state
: STATE { $$ = new State($1); }
;

enddef
: ';'
| /* empty */
;

enddef1
: ';'
;

%%

/* Lexical analyzer */

static private ClassLoader CLASSLOADER = AmtParser.class.getClassLoader();
static private int BUFF_SIZE = 256;
private Stack ch = new Stack();
private InputStream inputStream = System.in;
private Map result = new HashMap();
private Map alias = new HashMap();
private List searchPath = new ArrayList(); { searchPath.add(""); };
private int lineno = 1;
private CharToByteConverter c2b = CharToByteConverter.getDefault();
private int inStringPattern = -1;
private Stack varStack = new Stack();
private int nextChar = -1;
private IVariable lastVariable = new Variable("_");

/* 2006 10 16, tabee@jp.ibm.com */
// They are initialized each time parsing a character-set expression
private int inCharSetPattern = -1;
private boolean charSetBegin = true;
private boolean isComplementCharSet = false;

public AmtParser() {
}

public AmtParser(String conv) {
    try {
        c2b = CharToByteConverter.getConverter(conv);
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
        c2b = CharToByteConverter.getDefault();
    }
}

public List getSearchPath() {
  return searchPath;
}

public void setAlias(ISymbol s1, ISymbol s2) {
  alias.put(s1, s2);
}

public void setAlias(String s1, String s2) {
  setAlias(new StringSymbol(s1), new StringSymbol(s2));
}

public void unsetAlias(ISymbol s1) {
  alias.remove(s1);
}

public void unsetAlias(String s1) {
  unsetAlias(new StringSymbol(s1));
}

public Map getResult(){
  return result;
}

public void setInputStream(InputStream istream){
  inputStream = istream;
}

public Map parse(InputStream istream){
  setInputStream(istream);
  yyparse();
  return getResult();
}

public Map parse(String str) {
  char cs[] = str.toCharArray();
  byte bs[];
  try {
    bs = c2b.convertAll(cs);
  } catch (MalformedInputException e) {
    bs = new byte[0];
  }
  ByteArrayInputStream bstream = new ByteArrayInputStream(bs);
  return parse(bstream);
}

public Object getParsedResult(String str) {
  return parse(str).get(lastVariable);
}

private int getch() {
  int c = 0;
  if (ch.isEmpty()) {
    try {
      c = inputStream.read();
    } catch (java.io.IOException e) {
      throw new Error(e.getMessage());
    }
  }
  else{
    c = ((Integer)ch.pop()).intValue();
  }
  if( c == '\n' ){
    lineno = lineno + 1;
  }
  return c;
}

private void ungetch(int c) {
  if( c == '\n' ) {
    lineno = lineno - 1;
  }
  ch.push(new Integer(c));
}

static private boolean isVariableChar(char c){
  return Character.isJavaIdentifierPart((char)c)
      || (c == '\'') || (c == '~') || (c == '^');
}

static private boolean isSymbolChar(char c){
  return Character.isJavaIdentifierPart((char)c)
      || (c == '\'') || (c == '~') || (c == '^');
}

static private boolean isSymbolFirstChar(char c){
  return Character.isJavaIdentifierStart((char)c)
      || (c == '@');
}

static final char specials[] = new char[]{
    '(', ')', '[', ']', '|', '&', '*', '+', '-', '/', '~', '^', '!', '?',
};
static final char concatChars[] = new char[]{
    ')', ']', '*', '+', '?',
};
static final Map charMap = new HashMap();
static {
  charMap.put("\\n", "\n");
  charMap.put("\\r", "\r");
  charMap.put("\\t", "\t");
  charMap.put("\\\\", "\\");
  charMap.put("\\.", ".");
  charMap.put(".", "\\.");
}

static private boolean isPatternSpecialChar(char c) {
  for (int i = 0; i < specials.length; i++) {
    if (c == specials[i]) return true;
  }
  return false;
}
static private boolean isPatternConcatChar(char c) {
  for (int i = 0; i < concatChars.length; i++) {
    if (c == concatChars[i]) return true;
  }
  return false;
}

static private boolean isPatternSymbol(char c) {
  return !isPatternSpecialChar(c);
}

/* 2006 10 16, tabee@jp.ibm.com */
private IPattern charRange(Character[] cs) {
  IPattern pat = null;
  char c1 = cs[0].charValue();
  char c2 = cs[1].charValue();
  for (char c = c1; c <= c2; c++) {
    if (pat == null) {
      pat = new SymbolPattern(new CharSymbol(c));
    } else {
      IPattern p2 = new SymbolPattern(new CharSymbol(c));
      pat = new UnionPattern(pat, p2);
    }
  }
  if (pat == null) pat = new EmptyPattern();
  return pat;
}

int yylexForCharSetPattern() {
  yylval = null;
  for (;;) {
    int c = getch();
    if (c < 0){
      return 0;
    }
    if ((char)c == '^') {
      if (charSetBegin && !isComplementCharSet) {
        isComplementCharSet = true;
        yylval = Character.toString((char)c);
        return c;
      }
    }
    
    if ((char)c == ']') {
      if (charSetBegin) {
        yylval = new Character(']');
      } else {
        yylval = Character.toString((char)c);
        return CHARSETEND;
      }
    } else if ((char)c == '-') {
      if (charSetBegin) {
        yylval = new Character('-');
      } else {
        int lookahead = getch();
        if ((char)lookahead == ']') {
          ungetch(']');
	      yylval = new Character('-');
	      return CHAR;
        }
        yyerror("Unreachable code.");
      }
    } else {
    	yylval = new Character((char)c);
    }

    if (charSetBegin) {
    	charSetBegin = false;
    }
    
    /*
     If the next character is '-', it is a character-range expression
     unless it's not the last character inside '[...]'
    */
	int lookahead = getch();
	if ((char)lookahead == '-') {
	  lookahead = getch();
	  if ((char)lookahead == ']') {
	    ungetch(']');
	    ungetch('-');
	    return CHAR;
	  }
	  yylval = new Character[] { (Character)yylval, new Character((char)lookahead) };
	  return CHARRANGE;
	} else {
	  ungetch(lookahead);
	  return CHAR;
	}
  }
}

int yylexForStringPattern() {
  yylval = null;
  for (;;) {
    if (nextChar > 0) {
      int c = nextChar;
      nextChar = -1;
      return c;
    }
    int c = getch();
    if (c < 0){
      return 0;
    }
    else if (isPatternSymbol((char)c)) {
      yylval = Character.toString((char)c);
      if (c == '\\') {
        c = getch();
        if (c > 0) {
          yylval = yylval + Character.toString((char)c);
        }
        if (charMap.containsKey((String)yylval)) {
          yylval = charMap.get((String)yylval);
        }
        else if (isPatternSpecialChar((char)c)) {
          yylval = Character.toString((char)c);
        }
      }
      else {
        if (charMap.containsKey((String)yylval)) {
          yylval = charMap.get((String)yylval);
        }
      }
      nextChar = ',';
      return SYMBOL;
    }
    else {
      yylval = Character.toString((char)c);
      if (isPatternConcatChar((char)c)) {
        nextChar = ',';
      }
      if (charMap.containsKey((String)yylval)) {
        yylval = charMap.get((String)yylval);
        return SYMBOL;
      }
      else {
        return c;
      }
    }
  }
}

int yylex() {
  if (inCharSetPattern >= 0) {
    return yylexForCharSetPattern();
  }
  if (inStringPattern >= 0) {
    return yylexForStringPattern();
  }

  yylval = null;
  for (;;) {
    int c = getch();
    if (c < 0){
      return 0;
    }
    else if (c == '#') {
      while (c != 0) {
        if( c == '\n' ) break;
        c = getch();
      }
    }
    else if (c == ' ' || c == '\t' || c == '\r' || c == '\n' ){
    }
    else{
      if (c == '$') {
        int n = 0;
        boolean dvar = false;
        char[] buf = new char[BUFF_SIZE];
        buf[n++] = (char)c;
        c = getch();
        if (c == '$') {
          dvar = true;
          c = getch();
        }
        while (isVariableChar((char)c)) {
          buf[n++] = (char)c;
          c = getch();
        }
        ungetch(c);
        yylval = new String(buf, 1, n-1);
        return (dvar ? DVARIABLE : VARIABLE);
      }
      if (c == '<') {
        int n = 0;
        char[] buf = new char[BUFF_SIZE];
        buf[n++] = (char)c;
        c = getch();
        while (c != '>') {
          buf[n++] = (char)c;
          c = getch();
        }
        buf[n++] = (char)c;
        yylval = new String(buf, 1, n-2);
        return STATE;
      }
      if (c == '"' || c == '\'')  {
        int n = 0;
        char[] buf = new char[BUFF_SIZE];
        buf[n++] = (char)c;
        int c2 = getch();
        while (c2 != c) {
          buf[n++] = (char)c2;
          c2 = getch();
          if( c2 == '\\' ){
            c2 = getch();
            continue;
          }
        }
        buf[n++] = (char)c2;
        yylval = new String(buf, 1, n-2);
        if (c == '"') {
          return STRING;
        }
        else{
          return SYMBOL;
        }
      }
      if (c == '-') {
        int c2 = getch();
        if (c2 == '>') {
          yylval = "->";
          return ARROW;
        }
        else{
          ungetch(c2);
        }
      }
      if (Character.isDigit((char)c) || c == '-') {
        int n = 0;
        char[] buf = new char[BUFF_SIZE];
        buf[n++] = (char)c;
        c = getch();
        while (Character.isDigit((char)c) || c == '.') {
          buf[n++] = (char)c;
          c = getch();
        }
        ungetch(c);
        String numStr = new String(buf, 0, n);
        if( numStr.indexOf(".") >= 0 ){
          yylval = new Double(numStr);
          return DOUBLE;
        }
        else{
          yylval = new Long(numStr);
          return INTEGER;
        }
      }
      if (c == '&'){
        c = getch();
        if (c == '&') {
          return AND;
        }
        else{
          ungetch(c);
          yylval = Character.toString('&');
          return '&';
        }
      }
      if (c == '|'){
        c = getch();
        if (c == '|') {
          return OR;
        }
        else{
          ungetch(c);
          yylval = Character.toString('|');
          return '|';
        }
      }
      if (c == '='){
        c = getch();
        if (c == '=') {
          return EQ;
        }
        else{
          ungetch(c);
          yylval = Character.toString('=');
          return '=';
        }
      }
      if (isSymbolFirstChar((char)c)) {
        int n = 0;
        char[] buf = new char[BUFF_SIZE];
        buf[n++] = (char)c;
        c = getch();
        while (isSymbolChar((char)c)) {
          buf[n++] = (char)c;
          c = getch();
        }
        ungetch(c);
        yylval = new String(buf, 0, n);
        if (yylval.equals("new")) {
          return NEW;
        }
        else if (yylval.equals("null")) {
          return NULL;
        }
        else if (yylval.equals("as")) {
          return AS;
        }
        else if (yylval.equals("ref")) {
          return REF;
        }
        else if (yylval.equals("search")) {
          return SEARCH;
        }
        else if (yylval.equals("alias")) {
          return ALIAS;
        }
        else if (yylval.equals("delete")) {
          return DELETE;
        }
        else if (yylval.equals("TreeGrammar")) {
          return TREEGRAMMAR;
        }
        else {
          return SYMBOL;
        }
      }
      else{
        yylval = Character.toString((char)c);
        return c;
      }
    }
  }
}


void yyerror(String msg) {
  Object t = (yylval == null) ? "" : yylval;
  System.err.println("line " + lineno + "(before '" + t + "'): " + msg);
}
